# JavaScript
- [Function.prototype.bind에 대해 설명하세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#1-functionprototypebind%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94)
- [this가 JavaScript에서 어떻게 작동하는지 설명하세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#2-this%EA%B0%80-javascript%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94)
- [이벤트 루프란 무엇인가요? 콜 스택과 태스크 큐의 차이점은 무엇인가요?](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#3-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-%EC%BD%9C-%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)
- [프로토타입 상속이 어떻게 작동하는지 설명하세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%81%EC%86%8D%EC%9D%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94)
- [이벤트 버블링(Event Bubbling)이란 무엇인지 설명하세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#5-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81event-bubbling%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94)
- [얕은 복사와 깊은 복사에 대해 설명하세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#6-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94)
- [attribute와 property의 차이점에 대해 설명해보세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#7-attribute%EC%99%80-property%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94)
- [브라우저 저장소(쿠키, 웹 스토리지)에 대해 설명해주세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#8-%EC%BF%A0%ED%82%A4%EC%99%80-%EC%9B%B9%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94)
- [스코프에 대해서 설명해보세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#9-%EC%8A%A4%EC%BD%94%ED%94%84%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94)
- [호이스팅에 대해서 설명해보세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#10-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94)
- [null, undefined, undeclared, NaN에 대해 각각 설명해주세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#11-null-undefined-undeclared-nan%EC%97%90-%EB%8C%80%ED%95%B4-%EA%B0%81%EA%B0%81-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [순수함수에 대해 불변성과 side effect와 연결해 설명해주세요.](https://github.com/haizellatte/frontend-interview-handbook/tree/main/JavaScript#12-%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4-%EB%B6%88%EB%B3%80%EC%84%B1%EA%B3%BC-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%EA%B3%BC-%EC%97%B0%EA%B2%B0%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [var, let, const 차이를 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#13-var-let-const-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [이벤트 버블링과 캡처링에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#14-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81%EA%B3%BC-%EC%BA%A1%EC%B2%98%EB%A7%81%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [원시자료형과 참조자료형의 차이에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#15-%EC%9B%90%EC%8B%9C%EC%9E%90%EB%A3%8C%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [동등연산자(==)와 일치연산자(===)의 차이에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#16-%EB%8F%99%EB%93%B1%EC%97%B0%EC%82%B0%EC%9E%90%EC%99%80-%EC%9D%BC%EC%B9%98%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [forEach() 루프와 map() 루프 사이의 주요 차이점을 설명할 수 있나요?](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#17-foreach-%EB%A3%A8%ED%94%84%EC%99%80-map-%EB%A3%A8%ED%94%84-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-%EC%99%9C-%EB%91%98-%EC%A4%91-%ED%95%98%EB%82%98%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80%EC%9A%94)
- [async, await 사용 방법을 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#18-async-await-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [strict mode은 무엇이며 사용하는 이유에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#19-strict-mode%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [AJAX에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#20-ajax%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [구조분해할당에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#21-%EA%B5%AC%EC%A1%B0%EB%B6%84%ED%95%B4%ED%95%A0%EB%8B%B9%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [spread문법과 rest문법에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#22-spread%EB%AC%B8%EB%B2%95%EA%B3%BC-rest%EB%AC%B8%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [화살표 함수에 대해 일반함수와 비교하여 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#23-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9D%BC%EB%B0%98%ED%95%A8%EC%88%98%EC%99%80-%EB%B9%84%EA%B5%90%ED%95%98%EC%97%AC-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [binding의 개념과 call, apply의 차이점에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#24-binding%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-call-apply%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)
- [제너레이터에 대하여 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#25-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [함수형 프로그래밍(Functional Programming)이란 무엇인지 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#26-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8Dfunctional-programming%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [ES6에서 화살표 함수는 언제 쓰며, 왜 사용하는가?](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#27-es6%EC%97%90%EC%84%9C-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%93%B0%EB%A9%B0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80)
- [자바스크립트에서 가비지 컬렉션에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#28-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [import와 require의 차이점과 각각 어떤 상황에서 사용하는지 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/JavaScript#29-import%EC%99%80-require%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-%EA%B0%81%EA%B0%81-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
------
<br />

## 1. Function.prototype.bind에 대해 설명하세요.
> bind() 메소드가 호출되면 새로운 함수를 생성합니다. 받게되는 첫 인자의 value로는 this 키워드를 설정하고, 이어지는 인자들은 바인드 된 함수의 인수에 제공됩니다. 
from. MDN

자바스크립트의 this는 다른 언어들과 다르게 호출될 때 바인딩 될 객체가 동적으로 결정됩니다. 이는 외부 함수와 중첩 함수/콜백 함수 내부의 메소드가 일치하지 않는 문제를 야기시키게 됩니다. 이때 Function.prototype.bind를 이용하여 해결할 수 있습니다.

```javascript
const person = {
	name: 'Lee',
  	foo(callback) {
    	setTimeout(callback.bind(this), 100);
    }
};

person.foo(function () {
	console.log(`Hi! my name is ${this.name}.`); // Hi! my name is Lee.
})
```
함수 호출없이 첫 번째 인수로 전달한 값으로, this와의 바인딩이 교체된 함수로 새롭게 만들어지기 때문에 콜백 함수 내부의 this와 외부 함수 내부의 this가 일치하는 결과를 얻을 수 있습니다. 이처럼 Function.prototype.bind는 주로 메서드의 this와 메서드 내부 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결할 때 사용됩니다.
bind는 Function.prototype의 메소드이기 때문에 모든 함수가 상속받아 사용할 수 있습니다.

**▶︎ bind를 안 쓰고 this를 사용할 경우**
```javascript
const person = {
	name: 'Lee',
  	foo(callback) {
    	setTimeout(callback, 100);
    }
};

person.foo(function () {
	console.log(`Hi! my name is ${this.name}.`); // Hi! my name is .
})
```
person.foo()는 일반 함수로서 호출되면서 this는 전역 객체 window를 가리키게 됩니다. 때문에 'Lee'가 아닌 빌트인 메소드 window.name를 뜻하게 되어 name 프로퍼티의 기본값인 빈 문자열('')로 출력되게 됩니다. 
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 2. this가 JavaScript에서 어떻게 작동하는지 설명하세요.
생성자 함수로 메서드를 호출할 때, 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요했고 이에 자바스크립트는 this라는 특수한 식별자를 제공하였습니다. 하지만 인스턴스만을 가리키는 다른 언어들과는 다르게 자바스크립트의 this는 호출 시점에 바인딩 될 객체가 동적으로 결정됩니다.

일반 함수로 호출할 경우, this는 전역 객체 window를 가리킵니다.
생성자 함수로 호출할 경우, 인스턴스를 가리킵니다.
이처럼 일반함수로 호출할 경우에는 전역 객체를 가리키다보니 this가 불일치하는 경우가 생겨 개발자가 의도한 바와 다른 경우를 초래할 수 있기 때문에 주의를 기울어야 합니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 3. 이벤트 루프란 무엇인가요? 콜 스택과 태스크 큐의 차이점은 무엇인가요?
자바스크립트는 싱글 스레드입니다. 이는 한 번에 하나의 태스크만 처리할 수 있음을 의미합니다. 하지만 우리가 개발을 하다보면 마치 동시에 작업이 되는 것처럼 느껴질 때가 있습니다. 이것이 바로 '이벤트 루프'의 역할입니다.
이벤트 루프는 브라우저에 내장되어 있는 기능으로 콜 스택에 현재 실행 중인 코드가 있는지. 태스크 큐에 대기중인 함수가 있는지를 반복적으로 확인하여 콜 스택이 비었다면 대기중인 함수를 이동시켜 비동기적으로 처리하게 됩니다. 때문에 이벤트 루프는 자바스크립트의 동시성을 지원하게 됩니다.

이벤트 루프에서 언급한 태스트 큐는 비동기 함수를 일시적으로 보관하는 영역입니다.
콜 스택은 자바스크립트의 엔진 중 하나로 함수가 호출되면 순차적으로 쌓인 후, 순차적으로 실행됩니다. 이때문에 자바스크립트를 싱글 스레드라고 하는 이유이기도 합니다.

이야기를 종합해보면 콜 스택과 태스크 큐의 가장 큰 차이점은 데이터를 처리하는 방식입니다. 앞서 이벤트 루프에서 설명한 바를 생각해보면 결국 코드가 실행되는 곳은 자바스트립트 엔진, 즉 콜 스택입니다. setTimeout과 같은 비동기 함수를 태스크 큐에 모아두었다가 콜 스택에서 동기적으로 평가하고 실행되게 됩니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 4. 프로토타입 상속이 어떻게 작동하는지 설명하세요.
> 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

### <u>상속(inheritance)</u>
객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 받아와서 그대로 사용할 수 있는 것을 의미합니다. 때문에 상속은 코드 재사용이라는 관점에서 매우 유용하며, 이를 이용하면 불필요한 중복을 제거하기 떼문에 개발 비용을 줄일 수 있습니다.
<br/>

### <u>프로토타입이란?</u>
객체지향 프로그래밍에서 핵심이라 할 수 있는 **객체 간 상속을 구현하기 위해** 사용됩니다.
어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 상속받은 하위(자식)) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있게 됩니다. 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 내부 슬롯에 저장되는 프로토타입은 객체가 생성될 때 객체 생성 방식에 따라 결정됩니다. 즉, 모든 객체는 하나의 프로토타입을 갖습니다.
<br/>

### <u>프로토타입 체인이란?</u>
[[Prototype]] 내부 슬롯의 값(=프로토타입)에 접근할 때는 접근자 프로퍼티( \_\_proto__ )를 사용하게 되는데, **\_\_proto__는 객체가 직접 소유한 프로퍼티가 아닌 Object.prototype의 프로퍼티 입니다. \_\_proto__가 가리키는 참조에 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색할 수 있습니다.** 즉, 모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있으며, 프로토타입 체인의 최상위 객체(종점)인 Object.prototype의 프로퍼티와 메서드는 모든 객체가 상속할 수 있다는 의미이기도 합니다. <br/>

프로토타입 체인은 단방향 링크드 리스트로 구현되어야 하기 때문에 접근자 프로퍼티( \_\_proto__ )를 사용하면 서로를 참조하는 양방향 프로토타입 체인이 생성되는 것을 방지할 수도 있습니다.<br/><br/>

### 결론
이야기를 종합해보자면 '자바스크립트는 프로토타입 객체지향 언어'이며, 모든 객체는 프로토타입을 가지고 있습니다. 이 말은 곧 모든 객체는 프로토타입 체인에 묶여있다는 의미이기도 합니다. 그렇기에 상속과 프로퍼티 검색 매커니즘을 구현할 수 있는 이유라고 정의할 수 있겠습니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 5. 이벤트 버블링(Event Bubbling)이란 무엇인지 설명하세요.
이벤트 버블링은 한 요소에 이벤트가 발생해 요소에 할당된 핸들러가 동작하면 이어 부모 요소의 핸들러가 동작하고, 가장 최상단에 위치한 부모요소를 만날때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 것을 의미합니다.
 

이벤트가 제일 깊은 곳에 있는 요소부터 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품, 즉 버블과 닮아 이벤트 버블링이라고 부릅니다. <br/><br/>
<p align="center"><img src='https://velog.velcdn.com/images/haizel/post/b94f9e23-04d6-4dec-8532-4c19c49a40c7/image.png' width='400px' /></p>

### 이벤트 버블링 중단하기

원하는 요소에서만 이벤트를 발생하게 하고 싶다면, `event.stopPropagation()`를 통해 버블링을 중단할 수 있습니다. 이를 사용하면 클릭한 타깃의 이벤만 발생하고 상위 요소로 이벤트가 전파되는 것을 막아줍니다.

```jsx
<form onclick="alert('버블링은 여기까지 도달하지 못합니다")">FORM
  <div onclick="event.stopPropagation()">클릭해주세요.</div>
</form>
```

> 💡 **한 요소의 이벤트 핸들러가 두개라면?**
<br />한 요소의 특정 이벤트를 처리하는 핸들러가 여러개라면, `event.stopPropagation()`를 통해 하나의 핸들러의 버블링을 멈추더라도 나머지 핸들러는 여전히 동작합니다.
<br /> 즉,  `event.stopPropagation()` 는 상위로 일어나는 버블링은 막아주지만, 같은 요소에 할당된 다른 핸들러들이 동작하는 건 막지 못합니다.
<br /> 따라서 상위로 일어나는 버블링을 중단하고, 같은 요소에 할당된 다른 핸들러의 동작도 막으려면 `event.stopImmediatePropagation()`를 사용하면 된다. 이 메서드를 사용하면 해당 요소에 할당된 이벤트를 처리하는 모든 핸들러의 동작이 중단된다.


> ❓ **이벤트 버블링 중단, 올바른가?**
<br />버블링은 매우 유용하므로, 버블링을 꼭 멈춰야 하는 상황이 아니라면 버블링을 막지 않는 것이 좋다.
<br /> - `event.stopPropagation()`을 사용한 영역은 ‘죽은 영역(Dead Zone)’이 되어버리기 때문입니다.
<br />- 불가피하게 버블링을 막아야한다면, 해당 메서드 대신 커스텀 이벤트 등을 사용해 이벤트 버블링을 통제하는 것이 권장됩니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 6. 얕은 복사와 깊은 복사에 대해 설명하세요.
객체, 배열, 함수와 같은 **참조타입**의 데이터는 복사 시 데이터의 값이 아닌, **값이 저장된 메모리의 주소**가 저장됩니다. 따라서 참조 타입의 데이터를 복사하는 방법으로 얕은 복사와 깊은 복사로 나뉩니다.

<p align="center"><img src='https://velog.velcdn.com/images/haizel/post/65a1b787-c48a-4bd0-bb4f-708826420b78/image.png' width='500px' /></p>

**얕은 복사**는 참조 타입 데이터가 저장한 `메모리의 주소값`을 복사하는 것을 의미합니다. 즉 메모리 상 같은 주소를 가르키는 참조 변수 하나가 더 생기는 방법입니다.

**깊은 복사**는 새로운 메모리 공간을 확보해 참조 타입 데이터의 `내용`을 복사하는 것을 의미합니다. 따라서 메모리 상 같은 내용을 가진 변수 혹은 객체가 하나 더 생기는 방법입니다.

<br />

깊은 복사는 대표적으로  `Array.prototype.slice`, `Spread 연산자,` `Object.assign`, `JSON.stringify` 4가지 방법을 통해 이뤄집니다.
하지만 slice와 Spread 연산자, Object.assign의 경우, 1레벨 즉 1차원 배열에 대해선 깊은 복사가 허용되나, 2레벨(2차원 배열) 이상부터는 깊은 복사가 허용되지 않는다는 문제가 있습니다.

따라서 완전한 깊은 복사를 하기 위해선 3가지 방법을 활용할 수 있습니다.

첫째, 모든 깊이에 객체를 복사할 수 있는 **재귀함수**를 구현하는 방법입니다. 하지만 모든 깊이에 대해 복사하는 코드를 구현해야하는 번거로움이 있고, 가독성 문제와 많은 메모리 공간을 차지한다는 문제가 있습니다.

두번째는 **JSON.parse & JSON.stringify**를 활용하는 방법입니다.
JSON.stringify를 활용해 데이터를 문자로 변형시키고. JSON.parse로 다시 문자를 객체 데이터로 변형시키면 2레벨 이상의 배열에서도 깊은 복사를 실현할 수 있습니다.  하지만 JSON은 function, arrow Function, undefined 데이터 타입에서는 사용이 불가능하다는 한계점이 존재합니다.

마지막으로 **Lodash 와 Ramda**와 같은 외부 라이브러리를 설치해 사용하는 방법이 있습니다. 마찬가지로 라이브러리를 추가 설치하고, 사용법을 익혀야하는 번거로움이 존재합니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 7. attribute와 property의 차이점에 대해 설명해보세요.
자바스크립트에서 attribute와 property 모두 `속성`을 의미하지만, `존재하는 위치, 값의 불별성`에 대한 차이점이 존재합니다.
<br />예를 들어, value 값이 ‘기본값’인 input 요소가 있다 가정할 때, 해당 input 요소가 html에 있다면 value는  attribute를 의미하고, html DOM 안에 있다면 property를 의미합니다.

즉, 두 속성의 첫번째 차이점은 **attribute는 html/document/file 안**에서, **property는 html DOM tree 안**에서 존재합니다.

그리고 **attribute는 정적으로 변하지 않은 값**이며, **property는 동적으로 값이 변할** 수 있습니다. 이것이 두 속성의 두번째 차이점입니다.

예를 들어 input값의 value를 변경하면, attribute는 여전히 기본값 그대로지만, property는 변경된 값으로 바뀝니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 8. 브라우저 저장소(쿠키, 웹 스토리지)에 대해 설명해주세요.
### 저장소(쿠키/웹스토리지)는 왜 필요한가
HTTP는 요청과 응답으로 이뤄지는 하나의 사이클이 끝나면, 연결이 끊어지는 무상태성을 가져 클라이언트의 상태를 보존하지 않습니다.

HTTP의 이러한 단점을 보완하고자 쿠키와 웹 스토리지를 통해 서버가 아닌 클라이언트의 사용자 정보 및 상태를 저장해두고 필요시마다 데이터를 꺼내서 서버의 전달하는 방식을 구현합니다.

### 쿠키(Cookie)
클라이언트(브라우저) 로컬에 저장하는 만료기간을 가진 작은 텍스트파일로, 서버와 클라이언트가 주고 받은 내용을 기억하고 불러올수 있는 역할을 수행합니다.

만료 기간을 정할 수 있어 사용자 인증이 유효한 시간을 명시할 수 있고, 브라우저가 종료되어도 만료 기간 내에는 클라이언트에 보관되어 인증이 유지된다는 특징이 있습니다.

쿠키는 로그인/사용자정보/접속 시간 등 세션을 관리하기 위해 사용하며, 사용자의 언어 환경, 다크/라이트 모드 등 사용자 맞춤형 페이지를 제공할 목적으로 사용됩니다.

**쿠키의 장점**

1. 대부분의 브라우저에서 지원한다.
2. 데이터의 유효기간을 지정할 수 있다.
3. XSS(사이트간 악성 JS 코드를 심는 행위) 공격으로부터 안전하다.
4. 서버에서 쿠키의 httpOnly 옵션을 설정하면, JS를 통해 쿠키에 접근하는 것을 막을 수 있다.

**쿠키의 단점**

1. 저장할 수 있는 데이터 용량이 매우 작다(최대 4kb)
2. 서버로 HTTP 요청시 매번 같이 전달되어야 해 서버와 네트워크 측면에 부담이 있다.
3. 쿠키 속 정보는 암호화되어 있지 않아 제 3자에게 탈취되어 악용될 수 있는 위험이 있다.
4. CSRF(사이트 간 요청 위조) 위협 존재하다.
- CSRF : 제 3자가 사용자의 요청을 가로채 변조하여 부당 이익을 취하는 행위를 말한다.
6. 문자열만 저장 가능하다.

<br />

### 웹 스토리지(Web Storage)
window 객체의 프로퍼티로 존재하기도 하는 웹 스토리지는 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 나온 새로운 방식의 데이터 저장소를 말합니다.

웹 스토리지로는 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있습니다.

**로컬 스토리지(Local Storage) vs 세션 스토리지(Session Storage)**

두 스토리지는 영구성과 데이터 공유 범위로 구분됩니다. 먼저 로컬 스토리지는 브라우저를 종료해도 데이터가 영구적으로 보관됩니다. 반면 세션 스토리지는 브라우저 종료 시 데이터도 함께 삭제됩니다.

또한 로컬스토리지는 도메인이 같다면 전역적으로 데이터가 공유된다는 특성이 있으나, 세션 스토리지는 도메인이 같더라도 브라우저가 다르면(탭 브라우저, 다른 브라우저) 브라우저 컨텍스트가 다르기 때문에, 브라우저마다 각각의 세션 스토리지가 형성되어 데이터가 공유되지 않습니다.

**웹 스토리지의 장점**

1. 서버에 불필요하게 데이터를 저장하지 않아도 되어 서버 부담이 줄어듭니다.
2. 쿠키에 비해 데이터 용량이 큽니다.(모바일 : 2.5MB / 데스크탑 : 5~10MB)
3. 문자열은 물론 자바스크립트의 모든 원시형 데이터와 객체타입을 저장할 수 있습니다.
4. 도메인 단위로 접근이 제한되는 CORS 특성 덕에 CSRF위협으로부터 안전합니다.

**웹 스토리지의 단점**
1. HTML5를 지원하는 브라우저에만 사용가능합니다.
2. JS코드를 통해 웹 스토리지에 쉽게 접근할 수 있어 XSS 공격에 취약합니다.

<br />

### 각 저장소는 언제 사용해야 할까.

- 쿠키 : 일시적으로 필요한 가벼운 데이터를 저장할 때
     - e.g. 다시보지않음 쿠키 팝업창, 로그인 자동 완성

- 로컬 스토리지 : 브라우저가 종료되어도 지속적인 데이터 저장이 필요할 때
     - e.g. 자동 로그인
- 세션 스토리지 : 브라우저가 종료되면 사라지는 일시적으로 데이터를 저장할 때
     - e.g. 일회성 로그인, 입력 폼 저장, 비로그인 장바구니

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 9. 스코프에 대해서 설명해보세요.
스코프는 '변수에 접근할 수 있는 범위'라고 할 수 있습니다. 자바스크립트에서 스코프는 전역 스코프와 지역 스코프로 나눌 수 있습니다.

**전역 스코프**
전역에 선언되어 있는 변수는 전역 스코프를 가지게 되는데 이것은 어느곳에서든지 해당 변수에 접근할 수 있다는 의미입니다.

```javascript
const a = 1; // 전역스코프

if(true){
console.log(a) // if문 밖의 변수 참조 가능
}
```

**지역 스코프**
지역 스코프에 선언된 변수는 해당 지역에서만 접근할 수 있고 해당 지역 밖에서는 접근할 수 없습니다. 지역 스코프는 함수 스코프와 블록 스코프로 나뉩니다. 
var로 선언한 변수는 함수만 지역 스코프로 인식하기 때문에 함수 스코프를 가진다고 할 수 있으며, let과 const는 중괄호로 둘러쌓인 블록을 지역 스코프로 인식하기 때문에 블록 스코프를 가진다고 할 수 있습니다.

```javascript
var a = '전역 스코프'
fuction fuc () {
 var a = '함수 스코프';
 console.log(a); 
}
fuc(); // '함수 스코프' 출력
console.log(a); // '전역 스코프' 출력

let b = '전역 스코프';
if(true){
 let b = '블록 스코프';
 console.log(b); // '블록 스코프' 출력
}
console.log(b); // '전역 스코프' 출력

```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 10. 호이스팅에 대해서 설명해보세요.
호이스팅이란 변수 또는 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 것 같이 동작하는 현상을 말합니다. var로 선언한 변수는 호이스팅시 undefined로 초기화합니다. let과 const로 선언한 변수는 호이스팅시 변수를 초기화하지 않습니다.

```javascript
console.log(a); // undefined
var a = 1;

console.log(b); // 참조 오류
let b = 2;
```

let은 초기화가 안 되었기 때문에 변수를 참조할 수 없습니다. 스코프에서 초기화가 되기까지 변수를 참조할 수 없는 구간을 TDZ 또는 일시적 사각지대라고 합니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 11. null, undefined, undeclared, NaN에 대해 각각 설명해주세요.
## null

null은 객체 형태의 빈 값으로, 값이 없는 것을 의도적으로 명시하기 위해 사용합니다.

```jsx
let name = null;
console.log(name) // null
console.log(typeof name) //object
```

## undefined (미정의 변수)

undefined는 변수를 선언하고 값을 할당하기 이전의 값으로, 변수에 값이 할당되지 않은 상태를 말합니다.

변수는 변수 선언, 초기화, 할당의 3단계를 거쳐 생성되는데 이때 자바스크립트 엔진이 변수를 초기화할 때 undefined를 사용합니다.

```jsx
let name;
console.log(name); //undefined
console.log(typeof name); //undefined
```

## undelared (미선언 변수)

접근 가능한 스코프 내에 변수의 선언 조차되지 않은 상태를 말합니다. undefined 타입을 갖습니다.

```jsx
console.log(name); //ReferenceError: name is not defined
console.log(typeof name); //undefined
```

## NaN

`Not a Number`의 약어로, 표현할 수 없는 수치형 결과를 나타냅니다. 이 속성은 값이 유효한 숫자가 아니라는 것을 나타냅니다.

단 주의해야 할 점은 NaN은 숫자 타입의 데이터 타입으로, 즉 컴퓨터로 표현할 수 없는 숫자 값을 의미합니다.

```jsx
let age = NaN;
console.log(age); //NaN
Console.log(typeof age); // number
```

## undefined == null vs undefined === null

```jsx
console.log(undefined == null); //true 
console.log(undefined === null); //false
```

동등 연산자(==) 는 자료형이 다르면 자동형변환으로 타입을 강제로 맞춰서 비교하는 연산자입니다.

undefined와 null은 각각 다른 자료형으로, 자동형변환을 거쳐 값을 비교하면 둘다 값이 없기 때문에 일치하다고 판단해 true를 반환합니다.

하지만 일치 연산자(===) 는 자료형까지 비교하기 때문에 undefined는 undefined타입, null은 의도적으로 빈 값이 들어간 object 타입이기 때문에 false가 반환됩니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 12. 순수함수에 대해 불변성과 side effect와 연결해 설명해주세요.
## 순수함수

순수함수란 함수 프로그래밍에서 자주 사용되는 개념으로, 2가지 조건을 모두 만족하는 함수를 말합니다.

첫째, 같은 입력 값에 대해 항상 동일한 출력 값을 반환하는 함수여야 합니다. 순수 함수는 입력 값이 변경되지 않는 한 항상 같은 결과 값을 반환하기 때문에 불변성을 유지합니다.

둘째, 함수 바깥 영역에 side effect, 즉 부수효과를 초래하지 않는 함수여야 합니다. 즉 함수 외부의 값이나 함수에 전달된 값을 변경하지 않는 함수를 말합니다.

```jsx
/*<-- 순수 함수 -->*/
const a = (x, y) => x + y;
const b = (arr, value) => arr.concat(value);
const c = arr => [...arr].sort((a, b) => a - b);

/*<-- 순수 함수 ❌ -->*/
// 항상 같은 결과를 return 하지 않음
const a = (x, y) => x + y + Math.random(); 
// 전달받은 arr에 value를 넣어서 데이터를 변경함
const b = (arr, value) => (arr.push(value), arr); 
// arr를 정렬해서 순서가 바뀌게 함
const c = arr => arr.sort((a, b) => a - b);
```

<br />

### 💡 사이드 이펙트(Side effect)

의도치 않게 발생하는 예측할 수 없는 효과들을 말하며 대표적으로 외부 함수의 값이나 상태를 변경하는 것을 말합니다.

사이드 이펙트는 원래의 목적과 다르게 발생하기 때문에 사이드 이펙트가 발생하지 않도록 주의해야 합니다.

### 💡불변성

자바스크립트에서 순수함수를 제작하기 위해선 데이터의 불변성을 유지하는 것이 중요합니다. 이때 함수의 전달인자로 참조 자료형이 전달되는 경우, 의도치 않게 해당 객체 자체를 바꾸는 사이드 이펙트를 만들어 불변성을 손상시킬 수 있습니다. 때문에 배열의 불변성을 보장하는 메서드인 map, filter, ruduce와 같은 고차함수를 많이 사용합니다.

### 💡함수형 프로그래밍

순수함수로 사이드 이펙트(부수효과) 없이 불변성을 보장할 수 있는 프로그래밍 패러다임을 말합니다.  디버깅이 수월하다는 장점이 있습니다. 

순수함수는 평가 시점이 무관하다는 특징을 가져 함수형 프로그래밍에서 효과적인 로직을 구성할 수 있도록 돕습니다.

<br />

## 순수 함수의 장점

1. 순수 함수는 불변성을 유지하기 때문에 `코드의 예측 가능성과 안정성`을 높여줍니다.
2. 함수를 호출하면 항상 동일한 결과를 반환하기 때문에 `함수를 디버깅하거나 테스트`하기 쉽습니다.
3. 순수 함수는 병렬처리와 메모이제이션 등을 적용하기 쉬워 `성능을 향상` 시키는데 도움을 줍니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 13. var, let, const 차이를 설명해주세요.
var는 함수 레벨 스코프로 var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다. 즉, 함수 외부에서 var 키워드로 선언한 변수는 전역 변수가 됩니다. 때문에 의도치 않게 중복 선언이 되는 경우 또는 변수 선언 이전에 참조할 수 있는 변수 호이스팅이 발생합니다. 반면, let, const는 블록 레벨 스코프로 코드 블록 내에서 선언했다면 모두 지역 변수로 인정합니다. 때문에 전역변수의 남발을 예방할 수 있습니다. 이 외에도 let과 const는 변수 중복 선언이 되지 않으며, 특히 const 같은 경우에는 재할당도 금지되기 때문에 안정성을 부여할 수 있습니다. 
```javascript
console.log(temp); // undefined

var temp;

console.log(temp); // undefined

temp = 1;

console.log(temp); // 1
```
```javascript
console.log(temp); // ReferenceError: temp is not defined

let temp;

console.log(temp); // undefined

temp = 1;

console.log(temp); // 1
```
let과 const에도 변수 호이스팅이 발생하는데, var와 다르게 ReferenceError가 발생한다는 점을 확인할 수 있습니다.
var는 선언과 초기화가 동시에 일어나지만, let과 const의 경우 선언과 초기화가 분리되어 진행됩니다. 즉, var와 마찬가지로 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언이 되어 먼저 실행되지만, 초기화는 변수 선언문에 도달했을 때 실행되기 때문에 참조 에러가 발생하는 것 입니다. 이렇게 선언 시점부터 초기화 시점 사이에 참조할 수 없는 구간을 일시적 사각지대(TDZ)라고 합니다.
참고로 const는 반드시 선언과 동시에 초기화를 해야하기 때문에, 즉 선언과 할당을 동시에 진행해야 합니다. 그렇지 않으면 SyntaxError가 발생합니다.
```javascript
const temp; // SyntaxError: Missing initializer in const declaration
```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 14. 이벤트 버블링과 캡처링에 대해 설명해주세요.
```html
<div onclick="alert('div에 할당한 핸들러!')">
  <em><code>EM</code>을 클릭했는데도 <code>DIV</code>에 할당한 핸들러가 동작합니다.</em>
</div>
```
위 코드는 div에 핸들러를 할당했지만 아래 em 태그나 code 태그를 클릭해도 동작합니다. 
이는 바로 버블링(bubbling)이라는 원리 때문입니다. <br/><br/>

### 🧋 버블링이란
한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고 그 위 부모 요소의 핸들러도 동작하여 가장 최상단의 조상 요소를 만날 때까지 반복합니다. **즉, 물속 거품처럼 제일 깊은 곳에서 거슬러 올라가며 요소 각각에 할당된 핸들러가 동작합니다.**
이벤트 버블링은 우리가 일일이 이벤트 위임을 해주지 않아도 되기 때문에 굉장히 유용합니다. 그렇기에 특별한 목적이 아닌 이상 버블링을 막지 않는 것이 좋습니다.
```html
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```
1. \<p>에 할당된 onclick 핸들러가 동작합니다.
2. 바깥의 \<div>에 할당된 핸들러가 동작합니다.
3. 그 바깥의 \<form>에 할당된 핸들러가 동작합니다.
document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다. 
<br/><br/>

그렇다면 캡처링이란 무엇일까요? <br/><br/>

### 📸 캡처링이란
버블링과 반대로 이벤트가 하위 요소로 전파되는 것을 캡처링이라고 합니다. 제일 처음 보여드린 예시 코드로 설명하면 code 태그를 클릭하면 최상위 조상에서 시작해 아래로 전파되는 **캡처링 단계**를 거칩니다. 클릭한 요소(target 요소)에 도착하면 실행이 되는데 이를 **타겟 단계**라 하며, 이때 이벤트가 타겟 요소에 전달되는 것 입니다. 이후 다시 위로 전파되는 **버블링 단계**가 일어나며 버블링 설명처럼 각 요소에 할당된 이벤트 핸들러가 호출되는 것입니다.

### 💡이벤트 위임이란
비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있습니다.
공통 조상에 할당한 핸들러에서 event.target을 이용하면 실제 어디서 이벤트가 발생했는지 알 수 있습니다. 이를 이용해 이벤트를 핸들링합니다.

cf. <br/>
1. [이벤트 위임](https://ko.javascript.info/event-delegation) <br/>
2. [버블링과 캡처링](https://ko.javascript.info/bubbling-and-capturing)

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>


## 15. 원시자료형과 참조자료형의 차이에 대해 설명해주세요.
원시자료형은 값을 참조하며 값 자체는 변경 불가능 하지만 참조자료형은 값의 주소를 참조하며 값의 변경이 가능하다는 차이가 있습니다.

### 원시자료형
> 객체가 아니면서 메서드도 가지지 않는 데이터 타입입니다. - from.MDN

#### 원시자료형의 종류
- String : 문자를 표현하는데 사용되는 원시자료형입니다.
- Number : 숫자를 표현하는데 사용되는 원시자료형입니다.
- Bigint : Number의 범위를 넘어서는 큰 정수를 표현하는데 사용되는 원시자료형입니다.
- Boolean : 참과 거짓을 표현하는데 사용되는 원시자료형입니다.
- Null : 의도적으로 빈 값을 표현하는데 사용되는 원시자료형입니다.
- Undefined : 선언 후 할당하지 않은 변수나 값이 주어지지 않은 인수에 자동으로 할당되는 원시자료형입니다.
- Symbol : 매번 고유한 값을 반환하며 고유한 값을 보장하기 위해 사용되는 원시자료형입니다.

#### 원시자료형의 특징
- 값을 참조합니다.
- 하나의 데이터만 담을 수 있습니다.
- 값 자체는 변경이 불가능하지만 변수에 재할당하여 수정은 가능합니다.
<br/>

![image](https://github.com/lapmu/frontend-interview-handbook/assets/115691844/933d073b-db39-4497-a8c0-9a4a1821d9eb)

<br/>

### 참조자료형
원시자료형이 아닌 모든 데이터를 말합니다.

#### 참조자료형의 종류
- Object : 'key'와 'value'로 구성되어있는 데이터입니다.
- Array : 리스트 형태로 구성되어 있는 데이터입니다.
- Function : 속성과 메서드를 가지고 있는 일급 객체이며 호출할 수 있는 데이터입니다.

#### 참조자료형의 특징
- 값의 주소를 참조합니다.
- 여러 개의 데이터를 담을 수 있습니다.
- 값 변경이 가능합니다. 

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 16. 동등연산자(==)와 일치연산자(===)의 차이에 대해 설명해주세요.
동등연산자는 타입을 변환하여 두 개의 피연산자가 동일한지 확인하여 Boolean값을 반환하며 일치연산자는 타입을 변환하지 않고 두 개의 피연산자가 타입까지 동일한지 확인하여 Boolean값을 반환합니다.

### 동등연산자(==)

```javascript

1 == 1 //true
1 == '1' //true
true == 1 //true

```

#### 동등연산자의 특징
두 피연산자의 타입이 다를 경우 비교하기 전에 동일한 타입으로 변환합니다.
- 숫자와 문자열을 비교할 경우 문자열을 숫자로 변환합니다.
- 하나의 피연산자가 boolean일 경우 boolean 피연산자가 true일 경우 1로 변환하고 false일 경우 +0으로 변환합니다.
- 피연산자가 null과 undefined일 경우 true를 반환합니다.
- 피연산자가 하나라도 NaN이면 false를 반환합니다.

### 일치연산자(===)

```javascript

1 == 1 //true
1 == '1' //false
true == 1 //false

```

#### 일치연산자의 특징
동등연산자와 달리 두 피연산자의 타입이 다를 경우 false를 반환합니다.
- 두 피연산자가 모두 null이거나 모두 undefined일 경우 true를 반환합니다.
- 피연산자가 하나라도 NaN이면 false를 반환합니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 17. forEach() 루프와 map() 루프 사이의 주요 차이점을 설명할 수 있나요?
### forEach
배열의 요소를 반복하는데 이때 각 요소에 대한 콜백을 실행합니다. forEach는 반복만 할 뿐 값을 반환하지는 않습니다.
```javascript
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  console.log(num, index)
});
```
### map
forEach와 마찬가지로 요소를 반복합니다. 단, 각 요소에 대한 콜백을 실행하여 새로운 배열을 결과값으로 내보냅니다.
```javascript
const a = [1, 2, 3];
const doubled = a.map((num) => {
  return num * 2;
});
```
이렇듯 두 메소드의 가장 큰 차이점은 새로운 배열을 반환하는가 안 하는가 입니다. 즉, 원본 배열을 변경하고 싶지 않다면 map 메소드를 사용할 수 있습니다. 단순히 배열의 반복을 위함이라면 forEach 메소드를 사용할 수 있습니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 18. async, await 사용 방법을 설명해주세요.
async와 await은 자바스크립트의 비동기 처리 방식 중 가장 최근 문법입니다. 그래서인지 기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와준다.

```javascript
async function logName() {
  var user = await fetchUser('domain.com/users/1');
  if (user.id === 1) {
    console.log(user.name);
  }
}
```
위 예제에서 fetchUser()는 서버에서 데이터를 받아오는 HTTP 통신 코드이다. 일반적으로 자바스크립트의 비동기 처리 코드는 콜백을 사용해야지 코드의 실행 순서를 보장받을 수 있다. 그런데 이 개념이 익숙하지 않을 수도 있다. 그럴 때 우리는 위 예제처럼 async await를 이용하여 실행 순서를 보장 받을 수 있다.
```javascript
async function 함수명() {
  await 비동기_처리_메서드_명();
}
```
함수의 앞에 async 라는 예약어를 붙입니다. 그러고 나서 함수의 내부 로직 중 HTTP 통신을 하는 비동기 처리 코드 앞에 await를 붙입니다. 여기서 주의할 점은 비동기 처리 메서드가 꼭 프로미스 객체를 반환해야 await가 의도한 대로 동작합니다.

일반적으로 await의 대상이 되는 비동기 처리 코드는 Axios 등 프로미스를 반환하는 API 호출 함수입니다.

```javascript
function fetchItems() {
  return new Promise(function(resolve, reject) {
    var items = [1,2,3];
    resolve(items)
  });
}

async function logItems() {
  var resultItems = await fetchItems();
  console.log(resultItems); // [1,2,3]
}
```
fetchItems() 함수는 프로미스 객체를 반환하는 함수입니다. logItems() 함수는 fetchItems() 함수의 결과 값인 items 배열이 resultItems 변수에 담깁니다.

이때 await를 사용하지 않았다면 데이터를 받아온 시점에 콘솔을 출력할 수 있게 콜백 함수나 .then()등을 사용해야 했어야 했지만 async await 문법 덕택에 비동기에 대한 사고를 하지 않아도 되는 것입니다. 

즉, awiat은 promise.then보다 좀 더 세련되게 프라미스의 result 값을 얻을 수 있도록 해주는 문법입니다. promise.then보다 가독성 좋고 쓰기도 쉽습니다.

또한 await은 프라미스가 처리되면 그 결과와 함께 실행이 재개되기 때문에 프라미스가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있어 CPU 리소스가 낭비되지 않는다는 장점도 있습니다.
<br /><br />

### 결론
async와 await을 사용하면 비동기를 완전히 이해하지 않아도 간편하게 사용할 수 있도록 만들어줍니다. 대신 async가 붙은 함수는 반드시 프라미스를 반환해야하며, 프라미스가 아닌 것은 프라미스로 감싸 반환합니다. 그리고 async 함수 안에서만 동작하는 await은 '기다리다'라는 의미처럼 프로미스가 처리될 때까지 기다린 후 결과를 반환합니다.
<br /><br />

cf. [자바스크립트 async와 await](https://joshua1988.github.io/web-development/javascript/js-async-await/)
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>


## 19. strict mode은 무엇이며 사용하는 이유에 대해 설명해주세요.

### 👮🏻‍♂️ Strict 모드
ES5에 처음 추가된 개념으로, 자바스크립트 코드에 더욱 엄격한 오류 검사를 적용하는 키워드입니다. 스크립트나 함수의 맨 처음에 `“use strict”` 지시어를 사용해 선언할 수 있습니다.

```jsx
/* 스크립트에서 strict 선언 */
"use strict";
let start = "Hi! I'm a strict mode script!";

/* 함수에서 strict 선언 */
function strict() {
	"use strict";
	return  "Hi! I'm a strict mode script!";
}
```

### 👮🏻‍♂️ Strict 모드의 이점
엄격모드에서는 이전에 통용되던 행동들을 제약합니다. 또한 몇 가지 중요한 기능을 수정하여 강력한 오류 검사와 함께 향상된 보안 기능을 제공합니다. 대표적인 이점은 다음과 같습니다.

1. 기존에는 무시되던 에러들을 throwing 합니다.
2. JavaScript 엔진의 최적화 작업을 어렵게 만드는 실수들을 바로 잡습니다. 때문에 엄격 모드로 작성된 코드는 동일하게 작성된 기존의 코드보다 더 빨리 작동하기도 합니다.
3. 엄격모드는 ECMAScript의 차기 버전들에거 정의 될 문법을 금지합니다.

### 👮🏻‍♂️ Strict 모드의 특징

#### 1. 선언되지 않은 전역 변수를 사용할 수 없다.

<img src="https://velog.velcdn.com/images/haizel/post/ad19d7a9-e65a-46ff-b809-8655ef2ce871/image.png" width="400" />

#### 2. 읽기 전용 프로퍼티에는 대입할 수 없다.

writable이 false로, 읽기 전용 객체에 쓰는 것이 불가능합니다. (read only 객체 수정 불가능)

<img src="https://velog.velcdn.com/images/haizel/post/af48532e-32a8-425a-99b9-929bb36029e1/image.png"/>


#### 3. 매개변수 이름이 중복되어서는 안된다.
<img src="https://velog.velcdn.com/images/haizel/post/4ffa26a8-8913-4f69-abfd-7478cadf29b5/image.png"/>

#### 4. this 포인터가 가리키는 값이 null, undefind인 경우 전역 객체로 반환되지 않는다.
this의 결과가 null, undefind인 경우, 전역객체 window를 반환하지 않고 그대로 반환하게 됩니다.

<img src="https://velog.velcdn.com/images/haizel/post/1b494f1c-e785-48a8-81e4-21d673385643/image.png" />

#### 5. 예약어를 사용할 수 없다.
예약된 키워드의 이름으로 변수 또는 함수를 생성할 수 없습니다.

<img src="https://velog.velcdn.com/images/haizel/post/c0acc606-29cd-4017-b91f-5dfb35b45b1b/image.png" />

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 20. AJAX에 대해 설명해주세요.
### Ajax란?

`AJax`란 Asynchronous JavaScript and XML의 약자로, 비동기 자바스크립트와 XML을 말합니다. 간단히 말하면, 서버와 통신하기 위해 `XMLHttpRequest`객체를 사용하는 것을 말합니다.

- JSON, XML, HTML, 일반 텍스트 파일 형태의 데이터를 주고 받을 수 있습니다.
- AJax의 가장 큰 특징인 `비동기성`은 페이지를 리프레시 하지 않고도 수행됩니다. 따라서 사용자의 Event가 있을 때, 전체 페이지가 아닌 부분적으로 업데이트할 수 있습니다.

### AJax를 사용하는 이유

기본적으로 HTTP 프로토콜은 클라이언트가 보낸 요청에 서버가 응답하면 연결이 끊어집니다. 때문에 이후 화면 내용을 갱신 하기 위해선 위 작업을 반복해야하는데, 이때 많은 자원과 시간 낭비됩니다.

AJax는 HTML 페이지의 전체가 가인 일부분만 갱신할 수 있도록 XMLHttpRequest 객체를 통해 서버에 요청합니다. 즉 필요한 데이터만 요청하고 받아 갱신하기 때문에 자원과 시간을 효과적으로 절약할 수 있습니다.

### AJax의 이점

1. 웹 페이지 전체를 다시 로딩하지 않고도, 페이지의 일부분만 갱신할 수 있다.
2. 웹페이지가 로드된 후에 서버로 데이터 요청을 보내거나, 서버로부터 데이터를 받을 수 있다.
3. 백그라운드 영역에서 서버로 데이터를 보낼 수 있다.
4. 서버의 처리가 완료될 때까지 기다리지 않아도 돼 웹 페이지의 속도가 향상된다.


### AJax의 한계점

1. 히스토리 관리가 되지 않고, 페이지간 이동 없는 통신 방법으로 보안 상의 문제가 생길 수 있다.
2. 연속으로 데이터를 요청하면 서버 부하가 증가될 수 있다.
3. Script로 작성되므로 디버깅에 용이하지 않다.
4. 클라이언트가 서버로 데이터를 요청하는 `클라이언트 풀링 방식`을 사용하므로, `서버 푸시 방식` 의 실시간 서비스는 만들 수 없다.
    > **클라이언트 풀링 방식 (Client Polling)** : 사용자가 직접 원하는 정보를 서버에게 요청하여 얻는 방식을 말한다.
    > 
    > **서버 푸시 방식 (Server Push)** : 사용자가 요청하지 않아도 서버가 알아서 특정 정보를 제공하는 것을 의미한다. 대표적으로 스마트폰의 각종 앱에서 자동으로 보내는 푸시 알림이 있다.


### ✍️ 한줄 정리

`AJax`란 **자바스크립트를 통해서 서버에 데이터를 비동기 방식으로 요청**하는 것을 말합니다. JSON이나 XML 형태로 **필요한 데이터만 받아 갱신**하기 때문에 자원과 시간을 절약할 수 있어 사용합니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 21. 구조분해할당에 대해 설명해주세요.
> 구조분해할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다. from.MDN

구조분해할당의 구문은 할당문의 좌변에서 리터럴 표현식을 사용하고 우변에는 원래 변수를 사용하여 원래 변수에서 어떤 값을 분해해 할당할 것인지 정의합니다.

### 배열 구조분해할당

```javascript

const x = [1, 2, 3, 4, 5];
const [y, z] = x;
console.log(y); // 1
console.log(z); // 2

```

#### 선언과 할당의 분리
변수의 선언과 할당을 분리해도 구조분해를 통해 값을 할당할 수 있습니다.

```javascript

let a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

```

#### 기본값 할당
변수에 기본값을 할당하면, 분해한 값이 undefined일 때 그 값을 대신 사용합니다.

```javascript

let a, b;

[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7

```

#### 두 변수 값 교환
구조 분해 할당 없이 두 값을 교환하려면 임시 변수가 필요하지만 하나의 구조 분해 표현식으로 두 변수의 값을 교환할 수 있습니다.

```javascript

// 구조분해할당 X
let a = 1;
let b = 3;
let c;

c = a;
a = b;
b = c;
console.log(a); // 3
console.log(b); // 1

// 구조분해할당 O
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1

```

### 객체 구조분해할당

```javascript

const o = {p: 42, q: true};
const {p, q} = o;

console.log(p); // 42
console.log(q); // true

```

#### 선언과 할당의 분리
변수의 선언과 할당을 분리해도 구조분해를 통해 값을 할당할 수 있습니다.


```javascript

let a, b;

({a, b} = {a: 1, b: 2});

```

#### 새로운 이름으로 변수 할당
객체로부터 속성을 해체하여 객체의 원래 key와는 다른 이름의 변수에 할당할 수 있습니다.

```javascript

const o = {p: 42, q: true};
const {p: foo, q: bar} = o;

console.log(foo); // 42
console.log(bar); // true

```

#### 기본값 할당
객체로부터 할당된 값이 undefined일 경우 변수에 기본값을 할당하게 됩니다.


```javascript

const {a = 10, b = 5} = {a: 3};

console.log(a); // 3
console.log(b); // 5

```


<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 22. spread문법과 rest문법에 대해 설명해주세요.

### spread문법
'spread'의 의미인 펼치다, 퍼트리다와 같이 객체 또는 배열을 펼칠 수 있습니다.

```javascript

const slime = {
  name: '슬라임'
};

const cuteSlime = {
  name: '슬라임',
  attribute: 'cute'
};

const purpleCuteSlime = {
  name: '슬라임',
  attribute: 'cute',
  color: 'purple'
};

console.log(slime); // {name: '슬라임'}
console.log(cuteSlime); // {name: '슬라임', attribute: 'cute'}
console.log(purpleCuteSlime); // {name: '슬라임', attribute: 'cute', color: 'purple'}

```

위의 코드를 보면 기존의 것을 건들이지 않고 새로운 객체를 만들었는데 이 상황에서 spread문법을 사용하면 번복되는 코드 없이 유용하게 사용할 수 있습니다.

```javascript

const slime = {
  name: '슬라임'
};

const cuteSlime = {
  ...slime,
  attribute: 'cute'
};

const purpleCuteSlime = {
  ...cuteSlime,
  color: 'purple'
};

console.log(slime); // {name: '슬라임'}
console.log(cuteSlime); // {name: '슬라임', attribute: 'cute'}
console.log(purpleCuteSlime); // {name: '슬라임', attribute: 'cute', color: 'purple'}

```

spread문법은 배열에서도 사용이 가능합니다.

```javascript

const animals = ['개', '고양이', '참새'];
const anotherAnimals = [...animals, '비둘기'];

console.log(animals); // ['개', '고양이', '참새']
console.log(anotherAnimals); // ['개', '고양이', '참새', '비둘기']

```

배열에서는 spread문법을 여러번 사용이 가능합니다.


```javascript

const numbers = [1, 2, 3, 4, 5];

const spreadNumbers = [...numbers, 1000, ...numbers];
console.log(spreadNumbers); // [1, 2, 3, 4, 5, 1000, 1, 2, 3, 4, 5]

```

### rest문법
rest문법은 spread문법과 유사하게 생겼지만 역할이 매우 다르며 객체, 배열, 함수의 파라미터에서 사용이 가능합니다.

#### 객체에서의 rest문법
rest문법을 객체와 배열에 사용할 때는 구조분해할당과 함께 사용됩니다. 주로 rest라는 키워드를 사용하게 되는데 추출한 값의 이름이 꼭 rest일 필요는 없습니다. 

```javascript

const purpleCuteSlime = {
  name: '슬라임',
  attribute: 'cute',
  color: 'purple'
};

const { color, ...rest } = purpleCuteSlime;
console.log(color);  // purple
console.log(rest); // {name: '슬라임', attribute: 'cute'}

```

#### 배열에서의 rest문법
객체에서와 같이 구조분해할당을 사용하여 원하는 값을 밖으로 꺼내고 나머지 값을 rest에 넣을수 있습니다.

```javascript

const numbers = [0, 1, 2, 3, 4, 5, 6];

const [one, ...rest] = numbers;

console.log(one); // 0
console.log(rest); // [1, 2, 3, 4, 5, 6]

```

#### 함수 파라미터의 rest문법
함수의 파라미터가 몇개가 될 지 모르는 상황에서 rest 파라미터를 사용하면 매우 유용합니다.


```javascript

function sum(...rest) {
  return rest;
}

const result = sum(1, 2, 3, 4, 5, 6);
console.log(result); // [1, 2, 3, 4, 5, 6]

```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 23. 화살표 함수에 대해 일반함수와 비교하여 설명해주세요.
화살표 함수는 ES6에 새롭게 추가된 문법으로, 기존 함수 표현식에 비해 간단하게 사용 가능합니다. 

또한 화살표 함수는 `익명 함수`로만 사용할 수 있어, 화살표 함수를 호출하기 위해 함수 표현식을 사용합니다.

```jsx
// 일반 함수
function foo() {
 ...
}

// 화살표 함수
const foo = () => {
 ...
}
```

<br />

### 1. This

자바스크립트에서 모든 함수는 실행될 때마다 함수 내부에 this 객체가 추가됩니다.

✅ **일반함수**

일반 함수는 함수 선언 시점이 아닌 ***호출 시점*** 에 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 `동적`으로 결정됩니다.

> **일반 함수의 this 바인딩**
> 
> - 함수 내부에서 실행시 → 전역 객체(window)를 가리킵니다.
> - 메소드 내부에서 실행시 → 메소드를 소유하고 있는 객체를 가리킵니다.
> - 생성자 함수에서 실행 시 → 새롭게 만들어진 객체를 가리킵니다.

✅ **화살표 함수**

화살표 함수는 ***함수를 선언*** 할 때 this에 바인딩할 객체가 `정적`으로 결정됩니다. 때문에 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킵니다.

또한 call, apply, bind 메소드를 통해 this를 변경할 수 없습니다.

<br/>

### 2. 생성자 함수로 사용 가능 여부

✅ **일반함수**

생성자 함수로 사용 가능합니다.

✅ **화살표 함수**

**prototype 프로퍼티**를 가지고 있지 않아, 생성자 함수로 사용할 수 없습니다.

```jsx
// <------ 일반 함수 ------>
function foo() {
	this.num = 1234;
}

const fooA = new foo();
console.log(fooA.num); // 1234

// <------ 화살표 함수 ------>
const arrFoo = () => {
	this.num = 1234;
}

const fooB = new arrFoo(); // Error
```
<br/>

### 3. arguments 사용 여부

> `arguments`는 함수에 전달된 인수 값을 담은 배열 객체를 말하며, 함수 내부에서 접근할 수 있습니다.
> 

✅ **일반함수**

함수가 실행될 때 암묵적으로 arguments 변수가 전달되어 사용할 수 있습니다.

✅ **화살표 함수**

화살표 함수는 arguments 변수가 전달되지 않는다.

```jsx
// <------ 일반 함수 ------>
function foo () {
  console.log(arguments[0]);
}

foo("a", "b", "c"); // "a"

// <------ 화살표 함수 ------>
const foo = () => {
  console.log(arguments[0]);
}

foo("a", "b", "c"); 
// ReferenceError: arguments is not defined at foo
```

화살표 함수에서 arguments객체는 부모 스코프의 값을 상속 받기 때문에, 화살표 함수에 arguments 변수를 사용하면 ‘`Uncaught ReferenceError: arguments is not defined` ’와 같이 arguments를 정의할 수 없다는 참조에러가 발생합니다.
따라서 화살표 함수로 arguments에 접근하려면 아래와 같이 `rest 파라미터`를  사용해 명시적으로 작성하면 해결할 수 있습니다.

```jsx
const foo = (...arg) => {
  const pick = arg[0];
  console.log(pick); // "a"
}

foo("a", "b", "c");
```
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 24. binding의 개념과 call, apply의 차이점

### binding?

binding은 this가 가리키는 객체를 바꾸는 것을 말합니다. this는 자바스크립트에서 기본적으로 window 객체를 가리킵니다. 하지만 객체 내부, 생성자 new 호출시, 명시적으로 bind시에 따라 this가 가리키는 객체는 바뀌게 되는데 이것을 binding이라고 합니다. 명시적으로 this가 가리키는 객체를 바꿔주는 것이 call, apply, bind입니다.

### call과 apply

call과 apply는 함수를 호출할 때 사용되며 첫번째 매개변수는 함수 내에서 this가 가리키는 값으로 사용됩니다. call은 두번째 매개변수부터 호출하는 함수의 인자로 사용하게 되고 apply는 두번째 매개변수에 작성되는 배열의 요소가 함수의 인자로 사용이 됩니다. 

```javascript

const obj = { name: 'Tom' }
const say = function (city) {
    console.log(`Hello, my name is ${this.name}, I live in ${city}`)    
}

  say('seoul') // Hello, my name is , I live in seoul
  say.call(obj, 'seoul') // Hello, my name is Tom, I live in seoul
  say.apply(obj, ['seoul']) // Hello, my name is Tom, I live in seoul

```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 25. 제너레이터에 대하여 설명해주세요.
제너레이터(Generator)는 중간에 원하는 부분에서 멈추었다가, 그 부분부터 다시 실행할 수 있는 능력을 가진 함수입니다. 이터러블이다.

```javascript
function* generatorFunc() { ... }

const generatorFunc2 = function* () { ... }
```
위 사용 예시를 보면 알 수 있듯이 function* 키워드를 사용하며, 제너레이터 함수를 호출하면 코드가 실행되지 않고, 대신 실행을 처리하는 특별 객체, '제너레이터 객체’가 반환됩니다. 때문에 next() 메소드나 for...of 반복문을 사용해 값을 얻을 수 있습니다.
<br/><br/>
이렇듯 일반 함수가 아닌 특수한 형태의 함수입니다. 
<br/><br/>
위 별표(*)의 위치는 function 키워드와 함수 이름 사이면 아무데나 붙여도 되지만, 일관성을 위해 function 키워드 바로 뒤에 붙이는 것을 권장합니다.

추가로, 제너레이터 함수는 화살표 함수를 사용할 수 없습니다!
<br/><br/>

그렇다면 일반 함수와 제너레이터 함수의 차이는 무엇일까?

|일반 함수|제너레이터 함수|
|-------|-----------|
|하나의 값(혹은 0개의 값)만을 반환 | 여러 개의 값을 필요에 따라 하나씩 반환(yield)할 수 있다. |
| 함수가 호출되면 그 함수에 대한 제어권은 호출된 함수 본인이 가진다. | 함수 실행의 제어권을 함수 호출자에게 양도할 수 있다. 즉, 함수 호출자는 함수 실행을 일시 정지 시키거나 다시 시작하게 하도록 할 수 있다.|
|이미 호출되어 전달받은 인자는 함수의 상태를 변경할 수 없다. | 호출을 해도 양방향으로 함수의 상태를 주고 받을 수 있다. |
|호출 시 함수의 코드 블록이 실행된다. | 제너레이터 객체를 생성하여 반환한다.|


> 제너레이터 객체란? <br/>
제너레이터 함수를 호출했을 때 리턴되는 객체이다.

<br/>

제너레이터 함수는 실행을 일시적으로 정지시킬 수 있다고 하였는데, 이것이 바로 yield라는 키워드 때문입니다.
```javascript
function* generatorFunction() {
  yield 42;
}
```
return가 매우 유사하다고 이해하면 됩니다! 이때 next() 메소드를 사용하여 재개할 수 있습니다.
<br/>

제네레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고 받을 수 있습니다. 이러한 특성을 활용하면 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있습니다. 즉, 프로미스의 후속 처리 메서드 then/catch/finally 없이 비동기 처리 결과를 반환하도록 구현할 수 있습니다.
<br/><br/>

cf.<br/>
[[세오토리] 제너레이터란?](https://seo-tory.tistory.com/77) <br/>
[[javascript.info] 제너레이터](https://ko.javascript.info/generators) 
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 26. 함수형 프로그래밍(Functional Programming)이란 무엇인지 설명해주세요.
객체 지향 프로그래밍에서는 변수의 상태를 공유하고 상태를 변경하기 때문에 예상치 못한 버그를 일으킬 수 있습니다. 함수형 프로그래밍은 이러한 객체 지향 프로그래밍의 단점을 보완한 프로그래밍 방법으로, 불변성으로 선언한 값을 복사해 변경하므로 반환되는 값이 예측이 가능합니다. 

**함수형 프로그래밍**은 계산을 수학적 함수의 평가로 취급하고, 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임입니다. 부수효과를 제거한 순수함수들로만 작성되어 프로그램의 동작을 이해하고 예측하기 쉽다는 장점이 있습니다.

### 장점
1. 사용하는 모든 데이터가 변경 불가능(immutable)하고 함수는 부수 효과를 가지고 있지 않기 대문에 동시성과 관련된 문제를 원천적으로 차단할 수 있습니다.
2. 함수는 입력과 그와 관련된 출력만을 책임지기 때문에 테스트가 쉽고 가독성이 좋습니다.
3. 고차함수로 인해 함수들 간의 결합/조합이 간결해집니다.
4. 코드 재사용성이 높으며, 깔끔하고 유지보수에 용이합니다.

### 단점
1. 함수형 프로그래밍에서는 반복문을 for문이 아닌 재귀를 통해 이뤄지는데, 재귀적 코드 스타일은 무한 루프에 빠질 수 있습니다.
2. 함수가 많아질수록 함수를 조합하기 복잡해지며, 꾸준한 리팩토링이 필요할 수 있습니다.
3. 광범위한 환경 설정이 필요할 수 있습니다.

<br />

## 함수형 프로그래밍의 특징

> ✏️ 한 줄 요약 : 부수 효과가 없는 순수 함수를 일급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.

### 1️⃣ 부수효과(Side Effect)

함수 내의 실행으로 인해 함수 외부에 영향을 주는 것을 의미합니다. 대표적으로 다음과 같은 변화가 발행하는 작업을 말합니다.

- 변수를 수정하거나, 객체의 필드를 저장하는 것
- 예외를 던지거나 오류를 발생시키며 실행을 중단하는 것
- 콘솔 또는 파일 I/O가 발생하는 것

### 2️⃣ 순수 함수

부수 효과를 제거한 함수를 순수함수라고 하며, 같은 입력 값에 대해 항상 동일한 출력 값을 반환합니다. 함수형 프로그래밍에서 사용하는 함수는 모두 순수 함수입니다.

- Memory 또는 I/O의 관점에서 Side Effect가 없는 함수
- 함수의 실행이 외부에 영향을 끼치지 않는 함수

✅ **장점**

- 함수 자체가 독립적이며, Side Effect가 없기 때문에 Thread에 안전성을 보장 받을 수 있다.
- Thread에 안전성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

### 3️⃣ 일급 객체(First-Class Object)

함수형 프로그래밍에서 함수는 일급 객체로 취급됩니다. 따라서 일급 객체 함수는 일급 객체로 취급되는 함수를 의미합니다. 일급 객체 함수는 사용에 제한이 없기 때문에 프로그램 내 어디서든 사용할 수 있어, 유연하고 유용합니다. 
일급 객체의 특징은 다음과 같습니다.

- 변수나 데이터 구조 안에 담을 수 있다.
- 파라미터로 전달할 수 있다.
- 반환 값으로 사용할 수 있다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
- 동적으로 property 할당이 가능하다.

### 4️⃣ 참조 투명성(Referential Transparency)

함수형 프로그래밍에서 함수는 항상 같은 동작을 진행합니다. 따라서 함수의 실행으로 인해 어떤 결과가 반환될지 예측할 수 있습니다. 즉, 동일한 인자에 대해서는 항상 동일한 결과값을 반환합니다.

- 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다.
- 참조 투명성을 통해 기존 값은 변경되지 않고 유지된다.

<br />

그 밖에도 함수형 프로그래밍은 불변성, 클로저, 유지관리 가능성, 모듈화 등의 특징을 가집니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 27. ES6에서 화살표 함수는 언제 쓰며, 왜 사용하는가?
1. 함수 본연의 기능을 직관적으로 잘 표현하는 문법이다. ex) 입출력
2. 코드를 간결하게 표현할 수 있다.
    - 파라미터가 하나라면 소괄호 생력이 가능하다.
    - return문이 한 줄이라면 중괄호를 생략할 수 있다.
3. 화살표 함수의 내부 this는 값을 변화시키지 않는다. 
```javascript
let practice = {
  object: function () {
    console.log(this);
  },
};

practice.object(); // practice
```
```javascript
let practice = {
  object: () => {
    console.log(this);
  },
};

practice.object(); // window
```
자바스크립트의 this는 호출할 때 동적으로 바인딩이 되는데 화살표 함수는 선언한 함수에 this가 없기 때문에 상위 환경 즉, 외부에 있던 this를 그대로 내부에 가져와서 사용하여 window 결과가 나온 이유이다.

이렇듯 화살표 함수는 this 바인딩 문제를 해결하기 위해 사용되기도 합니다. 그러나 오히려 상위 환경의 this를 참조한다는 점이 문제가 될 수도 있습니다.
```javascript
const cat = {
  name: 'meow';
  callName: () => console.log(this.name);
}

cat.callName(); // undefined
```
위 예제처럼 callName 메소드의 this가 자신을 호출한 객체 cat이 아닌 상위 스코프를 가리키게 되면서(전역 객체를 가리킴) undefined 결과가 나왔습니다.
일반 함수를 사용해도 메소드로 호출하면 자신을 호출한 객체를 가리키기 때문에 메소드에서는 화살표 함수를 사용할 필요가 없습니다!!!! 이 밖에도 생성자 함수를 만들 수 없습니다. 
<br /><br />

### 정리

#### 💬 화살표 함수는 언제 사용하면 좋을까? <br />
함수를 간략히 정의하고 싶고 this를 사용하지 않거나 콜백함수의 this와 외부 함수의 this 간의 불일치 즉, this 바인딩 문제를 해결하고 싶을 때 사용한다.

#### 💬 화살표 함수를 사용하면 안되는 곳 <br />
- 메소드
- 생성자 함수

#### 👀 화살표 함수 사용의 좋은 예시
```javascript
let obj = {
  myVar: 'foo',
  
  myFunc: function() { 
    console.log(this.myVar)  
  
    setTimeout(() => {
      console.log(this.myVar)
    }, 1000)
  }
}
obj.myFunc() // foo (1초 뒤) foo
```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>

## 28. 자바스크립트에서 가비지 컬렉션에 대해 설명해주세요.

자바스크립트는 눈에 보이지 않는 곳에서 가비지 컬렉터가 가비지 컬렉션을 활용하여 메모리 관리를 합니다. '도달가능성'이라는 개념을 통해 메모리 관리를 수행합니다. '도달 가능성'이라는 개념은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 것을 의미합니다. 또한 자바스크립트 엔진 내에서 가비지 컬렉터가 끊임없이 동작하며 모든 객체를 모니터링하고 도달할 수 없는 객체를 삭제합니다.

<p align="center"><img src="https://github.com/lapmu/frontend-interview-handbook/assets/115691844/a22ece42-fec7-4b6b-a420-dffa83323857" width='400px'/></p>

```javascript

let user = {
  name: "John"
}; // (1)

user = null; // (2)
```

(1)에서 전역변수 user는 name을 키로 갖고 문자열 John을 값으로 갖는 객체를 참조합니다. user의 값을 다른 값으로 덮어쓰게 되면 즉 재할당을 하게 되면 앞의 객체를 참조하는 변수는 사라지게 됩니다. (2)에서 name을 키로 갖고 문자열 John을 값으로 갖는 객체에 접근할 방법이 사라졌습니다. 즉, 도달할 수 없는 상태가 되었습니다. 이때 가비지 컬렉터는 객체에 저장된 데이터를 삭제하고 객체를 메모리에서 삭제합니다.

### 가비지 컬렉션의 내부 알고리즘

가비지 컬렉션은 'mark-and-sweep’이라 불리는 알고리즘을 사용합니다.

<p align="center"><img src="https://github.com/lapmu/frontend-interview-handbook/assets/115691844/a26c9288-7b51-4eb6-8d40-8bac74d57a66" width='400px'/></p>

1. 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 mark 합니다.
2. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 합니다.
3. mark 된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark 합니다. 한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.
4. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.
5. mark 되지 않은 모든 객체를 메모리에서 삭제합니다.

### 가비지 컬렉션의 최적화

가비지 컬렉션은 자바스크립트 엔진은 실행에 영향을 미치지 않으면서 처리속도를 높이기 위해 다양한 최적화 기법을 사용합니다.

- generational collection(세대별 수집) – 객체를 새로운 객체와 오래된 객체로 나눕니다. 객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 새로운 객체로 구분합니다. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거합니다. 일정 시간 이상 동안 살아남은 객체는 오래된 객체로 분류하고, 가비지 컬렉터가 덜 감시하게 됩니다.
- incremental collection(점진적 수집) – 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모됩니다. 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려지게 됩니다.. 자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다. 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있습니다.
- idle-time collection(유휴 시간 수집) – 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.

### 요약!

- 가비지 컬렉션은 메모리를 효율적으로 관리하기 위해 사용됩니다.
- 가비지 컬렉션은 엔진이 자동으로 수행합니다. 따라서 개발자는 이를 임의로 실행하거나 막을 수 없습니다.
- 해당 객체가 도달 가능할 수 없는 상태일 때 가비지 컬렉터가 가비지 컬렉션을 수행하여 메모리에서 해당 객체를 제거합니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>
  
## 29. import와 require의 차이점과 각각 어떤 상황에서 사용하는지 설명해주세요.
`require`과 `import`는 모듈 키워드로 둘다 외부 파일이나 라이브러리를 불러오는 목적으로 사용되지만, 다른 문법 구조를 가지고 있습니다.

**require**

```jsx
/* 불러오기 */
const name = require('./module.js');

/* 내보내기 */
const name = '고양이';
/* 단일 객체 */
module.exports = name;
/* 복수 객체 */
exports.variable = name;
```

**import**

```jsx
/* 불러오기 */
import name from './module.js';

/* 내보내기 */
const name = '고양이';
/* 단일 객체 */
export default name;
/* 복수 객체 */
export name;
```

### `require`과 `import`의 주요 차이점

1. `require`은 NodeJS에서 사용되는 CommonJS의 키워드이고, `import`는 ES2015에서 새롭게 도입된 키워드입니다.
2. `require`은 프로그램의 어느 지점에서나 호출할 수 있지만, `import`는 파일의 시작 부분에서만 실행할 수 있습니다.
    
    > ⚠️ 최근엔 import 전용 비동기 문법으로 파일 중간에 모듈 불러오기를 할 수 있습니다.
    > 
3. 기본 모듈 시스템으로 CommonJS를 사용하는 NodeJS는 별도 컴파일러 없이 `require`를 통해 외부 파일이나 라이브러리를 불러오지만, ES6 모듈 시스템을 채택하는 리액트는 `import`를 통해 라이브러리를 불러옵니다. 이때 Babel과 같은 ES6 코드를 변환해주는 도구가 없다면 `require` 키워드를 사용해야 합니다.
4. 일반적으로 `import`는 사용자가 필요한 모듈을 부분적으로 로드할 수 있기 때문에 더 선호되며, `require` 보다 성능이 우수하고 메모리를 절약할 수 있습니다.

**⚠️ 이때 하나의 프로그램에서 두 키워드를 동시에 사용할 수 없으므로, 하나의 키워드를 선택해 사용해야 합니다.**
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/blob/main/JavaScript/README.md#javascript)
<br/><br/>
